"""
Decision-making endpoints
"""
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from models.base import db
from models.decision import Decision, Outcome
from models.user import Farmer
from models.crop import Crop
from services.decision_engine import DecisionEngine
from services.analytics_service import AnalyticsService
from middleware.validators import validate_request, GetAdviceSchema, OutcomeSchema
from utils.errors import ValidationError, NotFoundError
from utils.decorators import track_performance
import logging
import os
from datetime import datetime, timedelta

from middleware.performance import PerformanceMonitor
from utils.logger import setup_logger

decisions_bp = Blueprint('decisions', __name__)
logger = setup_logger(__name__)
engine = DecisionEngine()
analytics_service = AnalyticsService()


@decisions_bp.route('/get-advice', methods=['POST'])
@jwt_required()
@track_performance
@validate_request(GetAdviceSchema)
def get_advice():
    """
    Get planting advice for a crop
    ---
    tags:
      - Decisions
    security:
      - bearerAuth: []
    parameters:
      - name: body
        in: body
        required: true
        schema:
          type: object
          required:
            - crop_id
          properties:
            crop_id:
              type: integer
              example: 2
            governorate:
              type: string
              example: "Tunis"
            seedling_cost:
              type: number
              example: 3.5
            market_price:
              type: number
              example: 2.0
            input_quantity:
              type: number
              example: 100.0
    responses:
      200:
        description: Comprehensive planting advice generated by the decision engine
      400:
        description: Validation error or missing parameters
      401:
        description: Authentication required (Bearer token missing or invalid)
      404:
        description: Crop or Farmer not found
    """
    user_id = int(get_jwt_identity())
    farmer = Farmer.query.get(user_id)
    
    if not farmer:
        raise NotFoundError('Farmer not found')
    
    data = request.validated_data
    crop_id = data['crop_id']
    governorate = data.get('governorate', farmer.governorate)
    
    # Extract financial settings (optional)
    seedling_cost = data.get('seedling_cost')
    market_price = data.get('market_price')
    input_quantity = data.get('input_quantity', 1.0) # Default to 1 unit if not specified
    
    # Validate crop exists
    crop = Crop.query.get(crop_id)
    if not crop:
        raise NotFoundError(f'Crop with ID {crop_id} not found')
    
    logger.info(f"Getting advice for farmer {user_id}, crop {crop_id}, gov {governorate}, in_qty={input_quantity}, cost={seedling_cost}, price={market_price}")
    
    try:
        result = engine.get_advice(user_id, crop_id, governorate, seedling_cost, market_price, input_quantity)
        
        return jsonify({
            'status': 'success',
            'data': result
        }), 200
    
    except Exception as e:
        logger.error(f"Decision engine error: {e}", exc_info=True)
        raise ValidationError('Failed to generate advice')



@decisions_bp.route('/history', methods=['GET'])
@jwt_required()
@track_performance
def get_history():
    """
    Get decision history for current user
    ---
    tags:
      - Decisions
    security:
      - bearerAuth: []
    parameters:
      - name: limit
        in: query
        type: integer
        default: 20
        description: Maximum number of records to return
      - name: offset
        in: query
        type: integer
        default: 0
        description: Number of records to skip
      - name: crop_id
        in: query
        type: integer
        description: Filter by specific crop ID
      - name: period_type
        in: query
        type: string
        enum: ['month', 'period', 'season']
        description: Type of period filter
      - name: period_value
        in: query
        type: string
        description: Value for the period filter (e.g., '1' for Jan, 'P1', or 'winter')
    responses:
      200:
        description: A paginated list of past decisions and total count
    """
    user_id = int(get_jwt_identity())
    
    try:
        limit = min(int(request.args.get('limit', 20)), 100)
        offset = max(int(request.args.get('offset', 0)), 0)
        crop_id = request.args.get('crop_id')
        period_type = request.args.get('period_type') # 'month', 'period', 'season'
        period_value = request.args.get('period_value')
    except (ValueError, TypeError) as e:
        logger.error(f"Invalid pagination parameters: {e}")
        raise ValidationError('Invalid pagination parameters. limit and offset must be integers')
    
    query = Decision.query.filter_by(farmer_id=user_id)
    
    # Apply Crop Filter
    if crop_id:
        query = query.filter(Decision.crop_id == crop_id)
        
    # Apply Period Filter
    if period_type and period_value:
        from sqlalchemy import extract
        if period_type == 'month':
            # period_value is 1-12
            query = query.filter(extract('month', Decision.timestamp) == int(period_value))
        elif period_type == 'period':
            # period_value is P1-P9
            query = query.filter(Decision.period_id == period_value)
        elif period_type == 'season':
            # period_value is 'winter', 'spring', 'summer', 'autumn'
            season_months = {
                'winter': [12, 1, 2],
                'spring': [3, 4, 5],
                'summer': [6, 7, 8],
                'autumn': [9, 10, 11]
            }
            months = season_months.get(period_value.lower())
            if months:
                query = query.filter(extract('month', Decision.timestamp).in_(months))

    decisions = query.order_by(Decision.timestamp.desc())\
        .limit(limit)\
        .offset(offset)\
        .all()
    
    total = query.count()
    
    history_data = [{
        'id': d.id,
        'date': d.timestamp.isoformat() if d.timestamp else None,
        'crop_name': d.crop.name if d.crop else None,
        'crop_icon': d.crop.icon if d.crop else None,
        'governorate': d.governorate,
        'recommendation': d.recommendation,
        'wait_days': d.wait_days,
        'confidence': d.confidence,
        'explanation': d.explanation,
        'weather_temp': d.weather_temp_avg,
        'period_name': d.period.name if d.period else None,
        'actual_action': d.actual_action,
        'advice_status': d.advice_status,
        'seedling_cost_tnd': d.seedling_cost_tnd,
        'market_price_tnd': d.market_price_tnd
    } for d in decisions]
    
    return jsonify({
        'decisions': history_data,
        'total': total,
        'limit': limit,
        'offset': offset
    }), 200


@decisions_bp.route('/history/filters', methods=['GET'])
@jwt_required()
@track_performance
def get_history_filters():
    """
    Get metadata for history filters including personal decision counts
    ---
    tags:
      - Decisions
    security:
      - bearerAuth: []
    responses:
      200:
        description: Filter options with counts
        schema:
          type: object
          properties:
            crops:
              type: array
              items:
                type: object
                properties:
                  id:
                    type: integer
                  name:
                    type: string
                  count:
                    type: integer
            months:
              type: array
              items:
                type: object
                properties:
                  value:
                    type: integer
                  name:
                    type: string
                  count:
                    type: integer
            periods:
              type: array
              items:
                type: object
                properties:
                  id:
                    type: string
                  name:
                    type: string
                  count:
                    type: integer
            seasons:
              type: array
              items:
                type: object
                properties:
                  value:
                    type: string
                  name:
                    type: string
                  count:
                    type: integer
    """
    user_id = int(get_jwt_identity())
    from sqlalchemy import func, extract
    
    # 1. Crop counts (All crops in system)
    all_crops = Crop.query.all()
    crop_counts = db.session.query(
        Decision.crop_id, 
        func.count(Decision.id).label('count')
    ).filter(Decision.farmer_id == user_id).group_by(Decision.crop_id).all()
    
    count_map = {c_id: count for c_id, count in crop_counts}
    
    crops_result = [{
        'id': crop.id,
        'name': crop.name,
        'count': count_map.get(crop.id, 0),
        'icon': crop.icon
    } for crop in all_crops]
    
    # 2. Month counts
    month_counts = db.session.query(
        extract('month', Decision.timestamp).label('month'),
        func.count(Decision.id).label('count')
    ).filter(Decision.farmer_id == user_id).group_by('month').all()
    
    month_map = {int(m): c for m, c in month_counts}
    months_result = []
    month_names = ['January', 'February', 'March', 'April', 'May', 'June', 
                   'July', 'August', 'September', 'October', 'November', 'December']
    for i, name in enumerate(month_names):
        months_result.append({
            'value': i + 1,
            'name': name,
            'count': month_map.get(i + 1, 0)
        })
        
    # 3. Agrarian Period counts
    from models.crop import AgrarianPeriod
    all_periods = AgrarianPeriod.query.all()
    period_counts = db.session.query(
        Decision.period_id,
        func.count(Decision.id).label('count')
    ).filter(Decision.farmer_id == user_id).group_by(Decision.period_id).all()
    
    p_count_map = {p_id: count for p_id, count in period_counts}
    periods_result = [{
        'id': p.id,
        'name': p.name,
        'count': p_count_map.get(p.id, 0)
    } for p in all_periods]
    
    # 4. Season counts
    seasons = {
        'winter': [12, 1, 2],
        'spring': [3, 4, 5],
        'summer': [6, 7, 8],
        'autumn': [9, 10, 11]
    }
    seasons_result = []
    for season_name, months in seasons.items():
        count = db.session.query(func.count(Decision.id)).filter(
            Decision.farmer_id == user_id,
            extract('month', Decision.timestamp).in_(months)
        ).scalar() or 0
        seasons_result.append({
            'value': season_name,
            'name': season_name.capitalize(),
            'count': count
        })
        
    return jsonify({
        'crops': crops_result,
        'months': months_result,
        'periods': periods_result,
        'seasons': seasons_result
    }), 200


@decisions_bp.route('/record-outcome', methods=['POST'])
@jwt_required()
@track_performance
@validate_request(OutcomeSchema)
def record_outcome():
    """
    Record the outcome of a decision
    ---
    tags:
      - Decisions
    security:
      - bearerAuth: []
    parameters:
      - name: body
        in: body
        required: true
        schema:
          type: object
          required:
            - decision_id
            - outcome
          properties:
            decision_id:
              type: integer
            outcome:
              type: string
              enum: [success, failure, unknown]
            yield_kg:
              type: number
            revenue_tnd:
              type: number
            notes:
              type: string
    responses:
      200:
        description: Outcome recorded successfully
      404:
        description: Decision not found
    """
    user_id = int(get_jwt_identity())
    data = request.validated_data
    
    decision = Decision.query.filter_by(
        id=data['decision_id'],
        farmer_id=user_id
    ).first()
    
    if not decision:
        raise NotFoundError('Decision not found')
    
    # Create outcome record
    outcome = Outcome(
        decision_id=decision.id,
        outcome=data['outcome'],
        yield_kg=data.get('yield_kg'),
        revenue_tnd=data.get('revenue_tnd'),
        notes=data.get('notes')
    )
    
    try:
        db.session.add(outcome)
        db.session.commit()
        logger.info(f"Outcome recorded for decision {decision.id}")
        
        return jsonify({
            'status': 'recorded',
            'message': 'Outcome recorded successfully',
            'outcome_id': outcome.id
        }), 200
    
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to record outcome: {e}")
        raise ValidationError('Failed to record outcome')


@decisions_bp.route('/<int:decision_id>/outcome', methods=['PUT'])
@jwt_required()
@track_performance
def update_outcome(decision_id):
    """
    Update an existing outcome
    ---
    tags:
      - Decisions
    security:
      - bearerAuth: []
    parameters:
      - name: decision_id
        in: path
        type: integer
        required: true
      - name: body
        in: body
        schema:
          type: object
          properties:
            outcome:
              type: string
            yield_kg:
              type: number
            revenue_tnd:
              type: number
            notes:
              type: string
    responses:
      200:
        description: Outcome updated successfully
      404:
        description: Decision or Outcome not found
    """
    user_id = int(get_jwt_identity())
    data = request.get_json()
    
    decision = Decision.query.filter_by(
        id=decision_id,
        farmer_id=user_id
    ).first()
    
    if not decision:
        raise NotFoundError('Decision not found')
        
    outcome = Outcome.query.filter_by(decision_id=decision.id).first()
    if not outcome:
        raise NotFoundError('Outcome not found for this decision')
        
    if 'outcome' in data:
        outcome.outcome = data['outcome']
    if 'yield_kg' in data:
        outcome.yield_kg = data['yield_kg']
    if 'revenue_tnd' in data:
        outcome.revenue_tnd = data['revenue_tnd']
    if 'notes' in data:
        outcome.notes = data['notes']
        
    try:
        db.session.commit()
        return jsonify({
            'message': 'Outcome updated successfully',
            'outcome': outcome.to_dict()
        }), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to update outcome: {e}")
        return jsonify({'error': 'Failed to update outcome'}), 500


@decisions_bp.route('/<int:decision_id>/action', methods=['PUT'])
@jwt_required()
@track_performance
def update_action(decision_id):
    """
    Update decision action status
    """
    # Reuse record_action logic but expose as PUT for semantic correctness on updates
    return record_action(decision_id)


@decisions_bp.route('/<int:decision_id>', methods=['DELETE'])
@jwt_required()
@track_performance
def delete_decision(decision_id):
    """
    Delete a decision and its associated outcomes
    ---
    tags:
      - Decisions
    security:
      - bearerAuth: []
    parameters:
      - name: decision_id
        in: path
        type: integer
        required: true
        description: ID of the decision to delete
    responses:
      200:
        description: Decision deleted successfully
      404:
        description: Decision not found
    """
    user_id = int(get_jwt_identity())
    
    decision = Decision.query.filter_by(
        id=decision_id,
        farmer_id=user_id
    ).first()
    
    if not decision:
        raise NotFoundError('Decision not found')
        
    try:
        db.session.delete(decision)
        db.session.commit()
        # Outcomes are cascade deleted by model definition
        
        logger.info(f"Deleted decision {decision_id} for user {user_id}")
        return jsonify({'message': 'Decision deleted successfully'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Failed to delete decision: {e}")
        return jsonify({'error': 'Failed to delete decision'}), 500


@decisions_bp.route('/<int:decision_id>', methods=['GET'])
@jwt_required()
@track_performance
def get_decision_details(decision_id):
    """
    Get detailed information about a specific decision
    
    Args:
        decision_id: Decision ID
    
    Returns:
        200: Decision details
        404: Decision not found
    """
    user_id = int(get_jwt_identity())
    
    decision = Decision.query.filter_by(
        id=decision_id,
        farmer_id=user_id
    ).first()
    
    if not decision:
        raise NotFoundError('Decision not found')
    
    # Get outcomes if any
    outcomes = Outcome.query.filter_by(decision_id=decision.id).all()
    
    return jsonify({
        **decision.to_dict(),
        'outcomes': [outcome.to_dict() for outcome in outcomes]
    }), 200


@decisions_bp.route('/stats', methods=['GET'])
@jwt_required()
@track_performance
def get_decision_stats():
    """
    Get comprehensive decision statistics for current user
    
    Returns:
        200: Detailed analytics including success rate, risks avoided, financial impact
    """
    user_id = int(get_jwt_identity())
    
    from sqlalchemy import func, case
    
    # Total decisions made
    total_decisions = Decision.query.filter_by(farmer_id=user_id).count()
    
    # Calculate success rate from outcomes
    total_outcomes = db.session.query(func.count(Outcome.id)).join(Decision).filter(
        Decision.farmer_id == user_id
    ).scalar() or 0
    
    successful_outcomes = db.session.query(func.count(Outcome.id)).join(Decision).filter(
        Decision.farmer_id == user_id,
        Outcome.outcome == 'success'
    ).scalar() or 0
    
    # Calculate success rate percentage
    if total_outcomes > 0:
        success_rate = round((successful_outcomes / total_outcomes) * 100, 1)
    else:
        # If no outcomes yet, estimate based on decisions
        # Assume 70% success rate for PLANT_NOW, 50% for WAIT (conservative)
        plant_now_count = Decision.query.filter_by(
            farmer_id=user_id,
            recommendation='PLANT_NOW'
        ).count()
        
        wait_count = Decision.query.filter_by(
            farmer_id=user_id,
            recommendation='WAIT'
        ).count()
        
        if total_decisions > 0:
            estimated_successes = (plant_now_count * 0.7) + (wait_count * 0.5)
            success_rate = round((estimated_successes / total_decisions) * 100, 1)
        else:
            success_rate = 0
    
    # Count risks avoided (WAIT recommendations)
    risk_avoided_count = Decision.query.filter_by(
        farmer_id=user_id,
        recommendation='WAIT'
    ).count()
    
    # Calculate estimated savings
    # Formula: risks_avoided * avg_crop_value
    # Using 200 TND as default average crop loss prevention value
    estimated_savings = risk_avoided_count * 200
    
    # Count by recommendation type
    recommendation_stats = db.session.query(
        Decision.recommendation,
        func.count(Decision.id).label('count')
    ).filter_by(farmer_id=user_id)\
     .group_by(Decision.recommendation)\
     .all()
    
    # Top crops
    crop_stats = db.session.query(
        Crop.name,
        func.count(Decision.id).label('count')
    ).join(Decision, Decision.crop_id == Crop.id)\
     .filter(Decision.farmer_id == user_id)\
     .group_by(Crop.name)\
     .order_by(db.desc('count'))\
     .limit(5)\
     .all()
    
    # Recent decisions trend (last 7 days)
    from datetime import datetime, timedelta
    week_ago = datetime.utcnow() - timedelta(days=7)
    recent_decisions = Decision.query.filter(
        Decision.farmer_id == user_id,
        Decision.timestamp >= week_ago
    ).count()
    
    return jsonify({
        'total_decisions': total_decisions,
        'success_rate': f"{success_rate}%",
        'risk_avoided_count': risk_avoided_count,
        'estimated_savings': estimated_savings,
        'total_outcomes_recorded': total_outcomes,
        'successful_outcomes': successful_outcomes,
        'recent_activity': recent_decisions,
        'by_recommendation': {stat[0]: stat[1] for stat in recommendation_stats},
        'top_crops': [{'name': name, 'count': count} for name, count in crop_stats]
    }), 200


@decisions_bp.route('/<int:decision_id>/record-action', methods=['POST'])
@jwt_required()
@track_performance
def record_action(decision_id):
    """
    Record farmer's actual action relative to advice
    ---
    tags:
      - Decisions
    security:
      - bearerAuth: []
    parameters:
      - name: decision_id
        in: path
        type: integer
        required: true
      - name: body
        in: body
        required: true
        schema:
          type: object
          required:
            - actual_action
          properties:
            actual_action:
              type: string
              enum: [planted_now, waited, not_planted]
            deviation_reason:
              type: string
    responses:
      200:
        description: Action recorded successfully
      400:
        description: Invalid action
      404:
        description: Decision not found
    """
    user_id = int(get_jwt_identity())
    
    try:
        # Validate request
        data = request.get_json()
        logger.info(f"ðŸ“¥ Received action record request from user {user_id} for decision {decision_id}: {data}")
        
        if not data or 'actual_action' not in data:
            logger.warning(f"âš ï¸ Missing actual_action in request from user {user_id}")
            return jsonify({'error': 'actual_action is required', 'received': data}), 400
        
        actual_action = data['actual_action']
        if actual_action not in ['planted_now', 'waited', 'not_planted']:
            logger.warning(f"âš ï¸ Invalid actual_action '{actual_action}' from user {user_id}")
            return jsonify({'error': f"Invalid action: {actual_action}. Must be one of [planted_now, waited, not_planted]"}), 400
        
        # Get decision
        decision = Decision.query.filter_by(
            id=decision_id,
            farmer_id=user_id
        ).first()
        
        if not decision:
            logger.error(f"âŒ Decision {decision_id} not found for user {user_id}")
            return jsonify({'error': f'Decision {decision_id} not found for your account'}), 404
        
        # Calculate advice_status based on recommendation vs actual_action
        advice_status = _calculate_advice_status(decision.recommendation, actual_action)
        
        # Update decision
        decision.actual_action = actual_action
        decision.advice_status = advice_status
        decision.deviation_reason = data.get('deviation_reason')
        decision.action_recorded_at = datetime.utcnow()
        
        # LINK TO ANALYTICS: Auto-generate outcome for immediate feedback (MVP/Demo Feature)
        # This ensures the user sees the result of their decision in the dashboard immediately.
        existing_outcome = Outcome.query.filter_by(decision_id=decision.id).first()
        if not existing_outcome:
            is_success = (advice_status == 'followed')
            
            # Estimate yield/revenue based on user settings or defaults
            # In a full production app, this would be entered later by the user.
            estimated_yield = 1000 if is_success else 400
            estimated_revenue = (estimated_yield * 1.5) # 1.5 TND/kg
            
            outcome = Outcome(
                decision_id=decision.id,
                outcome='success' if is_success else 'failure',
                yield_kg=estimated_yield,
                revenue_tnd=estimated_revenue,
                notes=f"Auto-generated outcome based on action: {actual_action}"
            )
            db.session.add(outcome)
            logger.info(f"âœ¨ Auto-generated outcome for decision {decision_id} to populate analytics")
        
        db.session.commit()
        
        logger.info(f"âœ… Action recorded for decision {decision_id}: {actual_action} -> {advice_status}")
        
        return jsonify({
            'status': 'success',
            'message': 'Action recorded successfully',
            'data': {
                'decision_id': decision_id,
                'actual_action': actual_action,
                'advice_status': advice_status
            }
        }), 200

    except Exception as e:
        import traceback
        error_trace = traceback.format_exc()
        logger.error(f"ðŸ”¥ Critical error recording action for decision {decision_id}: {str(e)}\n{error_trace}")
        db.session.rollback()
        return jsonify({
            'error': 'Internal server error recording action',
            'details': str(e),
            'trace': error_trace if os.environ.get('FLASK_ENV') == 'development' else None
        }), 500


def _calculate_advice_status(recommendation, actual_action):
    """
    Calculate whether farmer followed or ignored advice
    
    Mapping Logic:
    - PLANT_NOW + planted_now â†’ followed
    - PLANT_NOW + waited â†’ ignored
    - WAIT + waited â†’ followed
    - WAIT + planted_now â†’ ignored
    - NOT_RECOMMENDED + not_planted â†’ followed
    - NOT_RECOMMENDED + planted_now â†’ ignored
    """
    mapping = {
        'PLANT_NOW': {
            'planted_now': 'followed',
            'waited': 'ignored',
            'not_planted': 'ignored'
        },
        'WAIT': {
            'waited': 'followed',
            'planted_now': 'ignored',
            'not_planted': 'followed'  # Not planting when told to wait is also following
        },
        'NOT_RECOMMENDED': {
            'not_planted': 'followed',
            'planted_now': 'ignored',
            'waited': 'ignored'
        }
    }
    
    return mapping.get(recommendation, {}).get(actual_action, 'pending')


@decisions_bp.route('/advanced-analytics', methods=['GET'])
@jwt_required()
@track_performance
def get_advanced_analytics():
    """
    Get comprehensive prescriptive analytics
    ---
    tags:
      - Analytics
    security:
      - bearerAuth: []
    parameters:
      - name: timeframe
        in: query
        type: string
        default: monthly
        enum: [weekly, monthly, seasonal, yearly]
        description: Timeframe for analytics aggregation
    responses:
      200:
        description: Advanced analytics dashboard data
        schema:
          type: object
          properties:
            aes:
              type: number
              description: Agronomic Efficiency Score (0-100)
            fci:
              type: number
              description: Financial Confidence Index
            rar:
              type: number
              description: Risk Avoidance Ratchet
            tls:
              type: number
              description: Tunisian Localization Score
            smart_summary:
              type: string
              description: AI-generated insight summary
            benchmarks:
              type: object
              description: Comparison with regional averages
    """
    user_id = int(get_jwt_identity())
    timeframe = request.args.get('timeframe', 'monthly')
    
    try:
        results = analytics_service.get_dashboard_data(user_id, timeframe)
        return jsonify(results), 200
    except Exception as e:
        logger.error(f"Analytics error: {e}")
        return jsonify({'error': 'Failed to generate analytics'}), 500


@decisions_bp.route('/simulate-data', methods=['POST'])
@jwt_required()
def simulate_data():
    """Seed data for the current user to demonstrate analytics"""
    user_id = int(get_jwt_identity())
    try:
        # Import here to avoid circular imports if any
        from models.decision import Decision, Outcome
        from models.crop import Crop
        import random
        
        # Add 10 mock decisions
        crops = Crop.query.limit(5).all()
        if not crops: return jsonify({'error': 'No crops found'}), 500
        
        for i in range(10):
            crop = random.choice(crops)
            recommendation = random.choice(['PLANT_NOW', 'WAIT'])
            advice_status = random.choice(['followed', 'ignored'])
            
            d = Decision(
                farmer_id=user_id,
                crop_id=crop.id,
                governorate='Tunis',
                recommendation=recommendation,
                confidence='HIGH',
                advice_status=advice_status,
                actual_action='planted_now', # Simplified
                timestamp=datetime.utcnow() - timedelta(days=random.randint(1, 100))
            )
            db.session.add(d)
            db.session.flush()
            
            # Outcome
            is_success = (advice_status == 'followed') # Followed = success
            Outcome(
                decision_id=d.id,
                outcome='success' if is_success else 'failure',
                yield_kg=1000,
                revenue_tnd=2000 if is_success else 0
            )
            
        db.session.commit()
        return jsonify({'status': 'simulated', 'message': 'Added 10 mock records'}), 200
    except Exception as e:
        db.session.rollback()
        logger.error(f"Simulation error: {e}")
        return jsonify({'error': 'Simulation failed'}), 500
